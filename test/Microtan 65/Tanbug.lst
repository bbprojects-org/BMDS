//
// Assembler for processor 6502
//
// File "Tanbug.asm"
// 23 Jan 2016, 17:38
//

0001                    //=============================================================================
0002                    //
0003                    // MICROTAN 65 - TANBUG
0004                    //
0005                    // The TANBUG monitor program is located in 1K bytes of read only memory
0006                    // (ROM) at the top of the 6502 microprocessor 64K byte address space.
0007                    //
0008                    // TANBUG will only operate in the memory map of the microtan system, it is
0009                    // not a general purpose 6502 software and has been specifically written for
0010                    // Microtan.
0011                    //
0012                    // Locations $F7F7, $F7F8 and $F7F9 are reserved for a jump to an expansion
0013                    // monitor ROM which is positioned on the expansion board.
0014                    // Locations $200 - $3FF are the visual display memory. TANBUG writes to these
0015                    // locations whenever a command is typed to the monitor.
0016                    // Locations $100 - $1FF are used as the stack by the microprocessor.
0017                    //
0018                    //=============================================================================
0019                    
0020    0000            TANEX         EQU    0                 // Tanbug Expansion = False (basic board)
0021                    
0022    0000                          ORG    $0                // Zero system page variables
0023                    
0024    0000            NULL          RMB    1                 // Reserved for bpt use
0025    0001            ICHAR         RMB    1                 // ASCII character
0026    0002            OCHAR         RMB    1                 // Temp char store
0027    0003            VDUIND        RMB    1                 // Display index
0028    0004            INTFS1        RMB    3                 // Fast interrupt link
0029    0007            NMIJP         RMB    3                 // NMI link
0030    000A            ICURS         RMB    2                 // Cursor index
0031    000C            RUNIND        RMB    1                 // Zero if in user mode
0032    000D            SINGLE        RMB    1                 // Nonzero if single instruction mode
0033    000E            PROCED        RMB    1                 // Proceed count (single instr to execute)
0034    000F            SIMCOM        RMB    1                 // Keypad (simple) / ASCII (complex) keyboard
0035    0010            INTSL1        RMB    3                 // Slow interrupt link
0036    0013            HXPKL         RMB    1                 // Hexpack store
0037    0014            HXPKH         RMB    1
0038                    
0039                    // Pseudo registers
0040                    
0041    0015            PCLBCK        RMB    1                 // PCL
0042    0016            PCHBCK        RMB    1                 // PCH
0043    0017            PSWBCK        RMB    1                 // PSW
0044    0018            SPBCK         RMB    1                 // SP
0045    0019            XBCK          RMB    1                 // IX
0046    001A            YBCK          RMB    1                 // IY
0047    001B            ABCK          RMB    1                 // A
0048                    
0049                    // Temporary stores
0050                    
0051    001C            MODADL        RMB    1
0052    001D            MODADH        RMB    1
0053    001E            COPL          RMB    1
0054    001F            COPH          RMB    1
0055                    
0056                    // Breakpoint status table and code store
0057                    
0058    0020            BPTLO         RMB    1
0059    0021            BPTHI         RMB    15
0060    0030            BPTCOD        RMB    16
0061                    
0062                    // Stack base
0063                    
0064    0100            STKBSE        EQU    $100
0065                    
0066                    // Display scroll labels
0067                    
0068    0200            VDUSTT        EQU    $200
0069    0220            VDUFST        EQU    $220
0070    0300            VDUMID        EQU    $300
0071    0320            VDUTOP        EQU    $320
0072    03E0            LINBOT        EQU    $3E0
0073                    
0074                    // I/O Ports
0075                    
0076    BFF0            SGRAPH        EQU    $BFF0
0077    BFF0            KBINCL        EQU    $BFF0             // Alternative to SGRAPH
0078    BFF1            SNMI          EQU    $BFF1
0079    BFF2            KBWRIT        EQU    $BFF2
0080    BFF3            KBREAD        EQU    $BFF3
0081    BFF3            STEXT         EQU    $BFF3             // Write to set text mode
0082                    
0083    F7F7            INPERR        EQU    $F7F7             // Error exit
0084                    
0085                    
0086                    #if TANEX
0087                                  ORG    $F800
0088                    
0089                                  JMP    $F951             // Jump table to utility routines
0090                                  JMP    $F9B2
0091                                  JMP    $F99B
0092                                  JMP    OPCHR1
0093                                  LDA    #13
0094                                  JMP    OPCHR
0095                                  JMP    $FAE9
0096                                  JMP    $FB0C
0097                                  JMP    HEXPCK
0098                                  JMP    HEXPNT
0099                                  JMP    POLLKB
0100                    
0101                                  LDX    #$FF
0102                                  TXS
0103                                  JMP    MONTOR
0104                    
0105                                  JMP    $FB16
0106                                  JMP    $FB23
0107                                  JMP    WASKB
0108                                  FDB    $FCF8
0109                    
0110                    SETUP         JMP    KBINT
0111                                  JMP    NMNT
0112                                  FDB    LINBOT            // ICURS setting
0113                                  FCB    1                 // RUNIND
0114                                  FCB    0                 // SINGLE
0115                                  FCB    0                 // PROCED
0116                                  FCB    0                 // SIMCOM
0117                                  FCB    $40               // Slow Interrupt (RTI instruction)
0118                    
0119                                  BIT    $0
0120                    #endif
0121                    
0122                    
0123                    // Start of ROM code for Microtan 65 TANBUG
0124                    
0125    FC00                          ORG    $FC00
0126                    
0127                    // TANBUG starts here on reset
0128                    
0129                    #if TANEX
0130                    START         JMP    $F83E
0131                    #else
0132    FC00  A2 FF     START         LDX    #$FF
0133    FC02  9A                      TXS                      // Set stack pointer to top of the stack
0134                    #endif
0135    FC03  E8                      INX                      //
0136    FC04  86 17                   STX    PSWBCK            // Clear breakpoint store as their values will be
0137                                                           // indeterminate on power up.
0138    FC06  20 B7 FF                JSR    BPTCLR            // Clear breakpoints
0139    FC09  8D F3 BF                STA    STEXT             // Set text mode
0140                    
0141                    // Use table in ROM to initialise parameters (note order of table must
0142                    // correspond with the order of INTFS1 to ICURSH in RAM definitions)
0143                    
0144                    #if TANEX
0145                                  LDX    #12
0146                    SETUP1        LDA    SETUP,X
0147                    #else
0148    FC0C  A2 0E                   LDX    #14
0149    FC0E  BD DF FF  SETUP1        LDA    SETUP,X           // SETUP holds parameter table
0150                    #endif
0151    FC11  95 04                   STA    INTFS1,X          // Store in zero page RAM
0152    FC13  CA                      DEX
0153    FC14  10 F8                   BPL    SETUP1
0154                    
0155                    // Determine keyboard type and set flag, note IX = $FF
0156                    
0157    FC16  E8                      INX
0158    FC17  8E F2 BF  TSFIV         STX    KBWRIT            // Clear keyboard write latch
0159    FC1A  8D F0 BF                STA    KBINCL            // Clear keyboard interrupt flag
0160    FC1D  CA                      DEX
0161    FC1E  8E F2 BF                STX    KBWRIT            // Write to keyboard lines
0162    FC21  E8                      INX                      // Reset IX
0163    FC22  AD F3 BF                LDA    KBREAD            // Read it back
0164    FC25  10 02                   BPL    KPCPLX            // If plus not set - alphanumeric
0165    FC27  E6 0F                   INC    SIMCOM            // If set - must be keypad
0166                    #if TANEX
0167                    KPCPLX        JSR    $FADB
0168                    #else
0169    FC29  8D F0 BF  KPCPLX        STA    KBINCL            // Clear keyboard interrupt
0170                    #endif
0171    FC2C  BD EC FF  TBMS          LDA    HDR,X             // Display TANBUG message
0172    FC2F  F0 06                   BEQ    MONTOR            // Output chars until a 0
0173    FC31  20 75 FE                JSR    OPCHR
0174    FC34  E8                      INX
0175    FC35  D0 F5                   BNE    TBMS
0176                    
0177                    
0178                    //
0179                    // MAIN LOOP - monitor user input and act accordingly
0180                    //
0181                    
0182    FC37  D8        MONTOR        CLD                      // Set binary mode
0183    FC38  58                      CLI
0184    FC39  20 FA FD                JSR    POLLKB            // Look at keyboard
0185    FC3C  A5 01                   LDA    ICHAR             // Get char
0186    FC3E  C9 21                   CMP    #$21              // Less than a space - term
0187    FC40  30 06                   BMI    MONCH1            // Else output char
0188    FC42  20 75 FE  ISTERM        JSR    OPCHR
0189    FC45  4C 37 FC                JMP    MONTOR
0190                    
0191    FC48  20 4F FC  MONCH1        JSR    MONEN2            // Call string process
0192    FC4B  A9 0D     RC1           LDA    #$0D              // Set up CR
0193    FC4D  D0 F3                   BNE    ISTERM            // Uncond. branch loop
0194                    
0195    FC4F  A0 00     MONEN2        LDY    #0
0196    FC51  B1 0A                   LDA    (ICURS),Y         // Pick up command
0197    FC53  AA                      TAX
0198    FC54  C8                      INY
0199    FC55  B1 0A                   LDA    (ICURS),Y         // Peek at next char
0200    FC57  10 36                   BPL    MULTI             // If not -ve (cursor) must be parameter
0201    FC59  A9 00                   LDA    #0                // Else set A to zero
0202                    
0203                    
0204                    //
0205                    // S - SINGLE INSTRUCTION MODE COMMAND
0206                    //
0207                    // This command switches single instruction mode ON.
0208                    // Single instruction mode is a very powerful debugging aid. When set
0209                    // TANBUG executes the user program one instruction at a time, re-entering
0210                    // the monitor between each instruction and printing out the status of all
0211                    // of the microprocessor's internal registers as they were after the last
0212                    // instruction executed in the user program.
0213                    // The S command is used in conjunction with the proceed command P and the
0214                    // normal mode command N.
0215                    //
0216                    
0217    FC5B  E0 53     TRYS          CPX    #$53              // Was it S?
0218    FC5D  D0 03                   BNE    TRYN
0219    FC5F  86 0D                   STX    SINGLE            // Yes - set single step mode
0220    FC61  60                      RTS
0221                    
0222                    
0223                    //
0224                    // N - NORMAL MODE COMMAND
0225                    //
0226                    // The N command is the complement of the S command and is used to cancel
0227                    // the S command so that the microprocessor executes the user program in
0228                    // the normal manner without returning to the monitor between each instruction.
0229                    // Reset automatically sets the normal mode of operation.
0230                    //
0231                    
0232    FC62  E0 4E     TRYN          CPX    #$4E              // Command N?
0233    FC64  D0 03                   BNE    TRYP
0234    FC66  85 0D                   STA    SINGLE            // else clear single instruction mode (ACC=0)
0235    FC68  60                      RTS
0236                    
0237                    
0238                    //
0239                    // P - PROCEED COMMAND (with no argument)
0240                    //
0241                    // This command is used to execute the next instruction when in single
0242                    // instruction mode (after the program has been started with a G command).
0243                    // The pseudo registers are reloaded and the next instruction executed.
0244                    // After execution, the microprocessor status is displayed as follows:
0245                    //	ADDR PSW SP IX IY ACC
0246                    // With no parameters entered, only the next instruction is executed
0247                    //
0248                    
0249    FC69  E0 50     TRYP          CPX    #$50              // Command P with no arg?
0250    FC6B  D0 04                   BNE    TRYR
0251    FC6D  85 0E                   STA    PROCED            // Clear P count (A=0)
0252    FC6F  F0 56                   BEQ    PROC1             // Uncond. branch proc
0253                    
0254                    
0255                    //
0256                    // R - REGISTER MODIFY / EXAMINE COMMAND
0257                    //
0258                    // This command is used to view / set the pseudo registers prior to running
0259                    // a program with the G command. It effectively executes a M15 command
0260                    // to examine the pseudo registers in locations $15 to $1B
0261                    //
0262                    
0263    FC71  E0 52     TRYR          CPX    #$52              // Command R?
0264    FC73  D0 09                   BNE    TRYB
0265    FC75  85 1D                   STA    MODADH            // Note A=0
0266    FC77  A9 15                   LDA    #$15              // Set pseudo reg
0267    FC79  85 1C                   STA    MODADL
0268    FC7B  4C E5 FD                JMP    REOPEN            // Jump mod memory
0269                    
0270                    
0271                    //
0272                    // B - BREAKPOINT COMMAND (no parameters)
0273                    //
0274                    // A breakpoint is a complementary debugging aid to single instruction mode.
0275                    // Instead of stepping singly through all instructions in a program, the
0276                    // breakpoint facility allows the user to specify the address at which he
0277                    // requires the monitor to be re-entered from his/her program. A breakpoint
0278                    // can be set just previous to where the fault is suspected to exist and the
0279                    // program started with the G command. Normal execution occurs until the
0280                    // breakpoint is reached, then the monitor is re-entered with the same status
0281                    // print-out as for single instruction mode. Any monitor commands can then be
0282                    // used and the program continued.
0283                    //
0284                    // With no parameters, the B command removes all breakpoints
0285                    //
0286                    
0287    FC7E  E0 42     TRYB          CPX    #$42              // Command B?
0288    FC80  D0 04                   BNE    ERRQ              // No - then error
0289    FC82  20 B7 FF                JSR    BPTCLR            // Else clear breakpoints
0290    FC85  60                      RTS
0291                    
0292                    
0293                    // With no TANEX FFF7 will respond to F7F7
0294                    // With TANEX, this monitor can be expanded since FFF7 jumps back to here
0295                    
0296                    #if TANEX
0297                    ERRQ          JMP    $FA75
0298                    #else
0299    FC86  4C F7 F7  ERRQ          JMP    INPERR
0300                    #endif
0301                    
0302    FC89  A9 3F     RETERR        LDA    #$3F
0303    FC8B  20 75 FE                JSR    OPCHR             // Display question mark
0304    FC8E  60                      RTS
0305                    
0306                    
0307                    // If we get here command expects parameters too
0308                    
0309    FC8F  88        MULTI         DEY   
0310    FC90  8A                      TXA                      // Save cmd on stack
0311    FC91  48                      PHA
0312    FC92  20 28 FF                JSR    HEXPCK            // Pack its argument
0313    FC95  D0 54                   BNE    MOREY             // Any more data?
0314    FC97  68                      PLA                      // Restore command
0315    FC98  50 EC                   BVC    ERRQ              // Error if no arg
0316                    
0317                    
0318                    //
0319                    // G - GO COMMAND
0320                    //
0321                    // Parameter is the address of the first instruction to run
0322                    // When executed the cursor disappears, and is restored on completion
0323                    // The program counter is initialised to the parameter address, and the
0324                    // stack pointer to $1FF (top of stack). The other registers: A, X, Y, PSW
0325                    // are loaded from the pseudo registers in the zero page ($15 - $1B)
0326                    //
0327                    
0328    FC9A  C9 47                   CMP    #$47              // Is it a G?
0329    FC9C  D0 21                   BNE    TRYPL             // No - skip
0330    FC9E  A2 00                   LDX    #0
0331    FCA0  86 0E                   STX    PROCED            // Clear proceed count
0332    FCA2  CA                      DEX                      // Set IX to $FF
0333    FCA3  9A        GOEND         TXS                      // Reload it
0334    FCA4  A5 14                   LDA    HXPKH             // Push PC high
0335    FCA6  48                      PHA
0336    FCA7  A5 13                   LDA    HXPKL             // Push PC low
0337    FCA9  48                      PHA
0338    FCAA  A5 17                   LDA    PSWBCK
0339    FCAC  48                      PHA
0340    FCAD  C6 0C                   DEC    RUNIND            // Clear run flag
0341    FCAF  A9 20                   LDA    #$20
0342    FCB1  A4 03                   LDY    VDUIND
0343    FCB3  91 0A                   STA    (ICURS),Y         // Obliterate cursor
0344    FCB5  A6 19                   LDX    XBCK
0345    FCB7  A4 1A                   LDY    YBCK
0346    FCB9  A5 1B     SRET          LDA    ABCK              // Set users Acc
0347    FCBB  8D F1 BF                STA    SNMI              // Set NMI for next
0348    FCBE  40                      RTI                      // Goto user prog
0349                    
0350                    
0351                    //
0352                    // P - PROCEED COMMAND (with argument)
0353                    //
0354                    // This command is used to execute the next instruction when in single
0355                    // instruction mode (after the program has been started with a G command).
0356                    // The pseudo registers are reloaded and the next instruction executed.
0357                    // After execution, the microprocessor status is displayed as follows:
0358                    //	ADDR PSW SP IX IY ACC
0359                    // If a parameter less than or equal to $FF is entered, then this number
0360                    // of instructions are executed before returning to the monitor
0361                    //
0362                    
0363    FCBF  C9 50     TRYPL         CMP    #$50              // Command P with arg?
0364    FCC1  D0 11                   BNE    TRYM
0365    FCC3  A5 13                   LDA    HXPKL             // Set P count
0366    FCC5  85 0E                   STA    PROCED
0367    FCC7  A5 16     PROC1         LDA    PCHBCK            // Restore users PC
0368    FCC9  85 14     PNOARG        STA    HXPKH
0369    FCCB  A5 15                   LDA    PCLBCK
0370    FCCD  85 13                   STA    HXPKL
0371    FCCF  A6 18                   LDX    SPBCK             // Set IX to users SP
0372    FCD1  4C A3 FC                JMP    GOEND             // Then back to user
0373                    
0374                    
0375                    //
0376                    // M - MODIFY/EXAMINE MEMORY COMMAND
0377                    //
0378                    // Parameter is the memory address to be examined / modified
0379                    // TANBUG shows memory address and location, and awaits user input:
0380                    // - any terminator, location not altered and closes command
0381                    // - value followed by terminator, modifies location with value, if terminator is
0382                    //	CR, closes command
0383                    //	SPACE, shows same location
0384                    //	LF, shows next memory location
0385                    //	ESC, shows previous memory location
0386                    //
0387                    
0388    FCD4  C9 4D     TRYM          CMP    #$4D              // Command M address?
0389    FCD6  D0 AE                   BNE    ERRQ              // No - error
0390    FCD8  A9 2C     EQPT          LDA    #$2C
0391    FCDA  20 75 FE                JSR    OPCHR             // Output a comma
0392    FCDD  A0 00                   LDY    #0
0393    FCDF  B1 13                   LDA    (HXPKL),Y         // Pick up value
0394    FCE1  20 0B FF                JSR    HEXPNT            // and display it
0395    FCE4  68                      PLA                      // Pop stack return
0396    FCE5  68                      PLA
0397    FCE6  A9 2C                   LDA    #$2C              // Load comma
0398    FCE8  4C 42 FC                JMP    ISTERM            // and back to monitor
0399                    
0400                    
0401                    // If here then there is a second parameter
0402                    
0403    FCEB  E0 2C     MOREY         CPX    #$2C              // Was term a comma?
0404    FCED  F0 04                   BEQ    GETPT2            // Yes - continue
0405    FCEF  68        LINKPH        PLA                      // Else pull command
0406    FCF0  4C 86 FC  LINKR         JMP    ERRQ              // and give error
0407                    
0408    FCF3  A5 13     GETPT2        LDA    HXPKL             // No comma - store previous
0409    FCF5  85 1C                   STA    MODADL            // in MODADL & MODADH
0410    FCF7  A5 14                   LDA    HXPKH
0411    FCF9  85 1D                   STA    MODADH
0412    FCFB  20 28 FF                JSR    HEXPCK            // Pack next value
0413    FCFE  D0 7C                   BNE    MOREY1            // Not cursor - more yet
0414    FD00  68                      PLA                      // Else pull command
0415    FD01  50 ED                   BVC    LINKR             // No argument? - error
0416                    
0417                    
0418                    //
0419                    // L - LIST COMMAND (see LISTIT routine below)
0420                    //
0421                    
0422    FD03  C9 4C                   CMP    #$4C              // Command L?
0423    FD05  F0 42                   BEQ    LISTIT            // Yes - list it
0424                    
0425                    
0426                    //
0427                    // O - OFFSET COMMAND
0428                    //
0429                    // The offset command is a program writing aid. It calculates branch offsets
0430                    // for the user for incorporation as arguments in branch instructions.
0431                    // Parameters are the address of the branch opcode, and the address of the
0432                    // destination. The result is the value to be used as the argument for the
0433                    // branch.
0434                    // Note that the maximum branch is $7F forwards, or backwards
0435                    //
0436                    
0437    FD07  C9 4F                   CMP    #$4F              // Command O?
0438    FD09  D0 27                   BNE    TRYBPT
0439    FD0B  A5 13                   LDA    HXPKL             // Get branch dest
0440    FD0D  38                      SEC
0441    FD0E  E9 02                   SBC    #2                // Adjust for branch code
0442    FD10  B0 02                   BCS    NOTOPO
0443    FD12  C6 14                   DEC    HXPKH
0444    FD14  38        NOTOPO        SEC   
0445    FD15  E5 1C                   SBC    MODADL            // Subtract source
0446    FD17  AA                      TAX                      // Hold result in IX
0447    FD18  A5 14                   LDA    HXPKH             // Subtract high byte
0448    FD1A  E5 1D                   SBC    MODADH
0449    FD1C  A8                      TAY                      // Store in IY
0450    FD1D  8A                      TXA                      // Get low byte
0451    FD1E  30 05                   BMI    RNGNG             // If -ve branch
0452    FD20  98                      TYA                      // If +ve look at high
0453    FD21  D0 CD                   BNE    LINKR             // Not 0 - then error
0454    FD23  F0 03                   BEQ    PNTITO            // If ok continue
0455                    
0456    FD25  C8        RNGNG         INY                      // If -ve, then high is $FF
0457    FD26  D0 C8                   BNE    LINKR
0458    FD28  A9 3D     PNTITO        LDA    #$3D
0459    FD2A  20 75 FE                JSR    OPCHR             // Ok - display equals sign
0460    FD2D  8A                      TXA
0461    FD2E  20 0B FF                JSR    HEXPNT            // ... and the value
0462    FD31  60                      RTS
0463                    
0464                    
0465                    //
0466                    // B - BREAKPOINT COMMAND (with parameters)
0467                    //
0468                    // As described above.
0469                    // Parameters are the address of any opcode instruction, and the number of the
0470                    // breakpoint to be set (0 to 7)
0471                    //
0472                    
0473    FD32  C9 42     TRYBPT        CMP    #$42              // Command B?
0474    FD34  D0 BA     LINK1         BNE    LINKR             // No - error
0475    FD36  A5 13                   LDA    HXPKL             // Maximum breakpoint code is 7
0476    FD38  30 B6                   BMI    LINKR
0477    FD3A  C9 08                   CMP    #8                // If greater - then error
0478    FD3C  10 B2                   BPL    LINKR
0479    FD3E  0A                      ASL    A                 // Double A
0480    FD3F  AA                      TAX                      // Set IX for indexed addressing
0481    FD40  A5 1C                   LDA    MODADL            // Store breakpoint address
0482    FD42  95 20                   STA    BPTLO,X
0483    FD44  A5 1D                   LDA    MODADH
0484    FD46  95 21                   STA    BPTHI,X
0485    FD48  60        JPRTRN        RTS   
0486                    
0487                    
0488                    //
0489                    // L - LIST MEMORY COMMAND
0490                    //
0491                    // Parameters are start memory address, and number of lines of 8 consecutive
0492                    // memory locations to show
0493                    // If 0 lines are requested, 256 lines will be shown
0494                    // TANBUG pauses between each line to permit the user to read the output
0495                    //
0496                    
0497    FD49  20 73 FE  LISTIT        JSR    OUTPCR            // Output carriage return
0498    FD4C  A0 00     NXLI          LDY    #0
0499    FD4E  A5 1D                   LDA    MODADH            // Display address
0500    FD50  20 0B FF                JSR    HEXPNT            // High byte ...
0501    FD53  A5 1C                   LDA    MODADL
0502    FD55  20 0B FF  NXLIST        JSR    HEXPNT            // Output low byte
0503    FD58  A9 20                   LDA    #$20
0504    FD5A  20 75 FE                JSR    OPCHR             // Output a space
0505    FD5D  B1 1C                   LDA    (MODADL),Y        // Display memory locations
0506    FD5F  C8                      INY
0507    FD60  C0 09                   CPY    #9                // For eight memory locations
0508    FD62  30 F1                   BMI    NXLIST
0509    FD64  C6 13                   DEC    HXPKL             // Decrement line count
0510    FD66  F0 E0                   BEQ    JPRTRN            // O? Return via CR (note requesting 0 lines gives 256)
0511                    
0512                    #if TANEX
0513                    DELX1         NOP   
0514                                  NOP
0515                                  NOP
0516                                  NOP
0517                                  NOP
0518                                  NOP
0519                    #else
0520    FD68  88        DELX1         DEY                      // Time delay
0521    FD69  D0 FD                   BNE    DELX1
0522    FD6B  CA                      DEX
0523    FD6C  D0 FA                   BNE    DELX1
0524                    #endif
0525                    
0526    FD6E  A5 1C                   LDA    MODADL            // Now adjust the address, for next 8 locations
0527    FD70  18                      CLC
0528    FD71  69 08                   ADC    #8
0529    FD73  85 1C                   STA    MODADL
0530    FD75  90 D2                   BCC    LISTIT            // If Carry set
0531    FD77  E6 1D                   INC    MODADH            // then increment high byte
0532    FD79  4C 49 FD                JMP    LISTIT
0533                    
0534                    
0535                    // If we get here there  is a third parameter
0536                    
0537    FD7C  E0 2C     MOREY1        CPX    #$2C              // Comma?
0538    FD7E  F0 03                   BEQ    TERMOK
0539    FD80  4C EF FC  ERJUM2        JMP    LINKPH            // No - then error
0540                    
0541    FD83  A5 13     TERMOK        LDA    HXPKL             // Else store parameter
0542    FD85  85 1E                   STA    COPL
0543    FD87  A5 14                   LDA    HXPKH
0544    FD89  85 1F                   STA    COPH
0545    FD8B  20 28 FF                JSR    HEXPCK            // then pack new para
0546    FD8E  D0 F0                   BNE    ERJUM2            // error not term
0547    FD90  68                      PLA
0548                    
0549                    
0550                    //
0551                    // M - MEMORY MODIFY / EXAMINE (modify location)
0552                    //
0553                    // If user has entered a value to be entered into the momeory location
0554                    // then this routine processes it
0555                    //
0556                    
0557    FD91  C9 4D                   CMP    #$4D              // Command M?
0558    FD93  F0 27                   BEQ    MEM100            // Yes - modify memory
0559                    
0560                    
0561                    //
0562                    // C - COPY COMMAND
0563                    //
0564                    // The copy command allows copying of the contents of one block of memory to
0565                    // another. The parameters are start address source, end address source and
0566                    // start address destination. These are copied to MODADL, COPL, and HXPKL
0567                    // respectively.
0568                    //
0569                    
0570    FD95  C9 43                   CMP    #$43              // Command C?
0571    FD97  D0 9B                   BNE    LINK1             // No - then error
0572    FD99  50 99                   BVC    LINK1             // Argument? Error if not
0573    FD9B  A0 00                   LDY    #0
0574    FD9D  B1 1C     NXCOP         LDA    (MODADL),Y        // Copy from source start address
0575    FD9F  91 13                   STA    (HXPKL),Y         // to destination
0576    FDA1  A5 1F                   LDA    COPH              // Check if we've reached end address
0577    FDA3  C5 1D                   CMP    MODADH
0578    FDA5  D0 06                   BNE    ICMCOP
0579    FDA7  A5 1E                   LDA    COPL
0580    FDA9  C5 1C                   CMP    MODADL
0581    FDAB  F0 5B                   BEQ    ENDLS
0582    FDAD  E6 1C     ICMCOP        INC    MODADL            // No, then increment source
0583    FDAF  D0 02                   BNE    NOHIH1
0584    FDB1  E6 1D                   INC    MODADH
0585    FDB3  E6 13     NOHIH1        INC    HXPKL             // and increment destination
0586    FDB5  D0 E6                   BNE    NXCOP
0587    FDB7  E6 14                   INC    HXPKH
0588    FDB9  D0 E2                   BNE    NXCOP             // Destination can not roll over top of memory
0589    FDBB  60                      RTS
0590                    
0591                    
0592                    // Modify memory location (M command above)
0593                    
0594    FDBC  A6 01     MEM100        LDX    ICHAR             // Get input character in IX
0595    FDBE  E0 20                   CPX    #$20              // Was it a space?
0596    FDC0  F0 23                   BEQ    REOPEN            // Yes - reopen
0597    FDC2  50 06                   BVC    NOENT             // Branch if nothing
0598    FDC4  A5 13                   LDA    HXPKL             // Else enter data
0599    FDC6  A0 00                   LDY    #0
0600    FDC8  91 1C                   STA    (MODADL),Y
0601                    
0602    FDCA  E0 0A     NOENT         CPX    #$0A              // Was LF typed?
0603    FDCC  F0 11                   BEQ    WASLF             // Yes - then process it
0604                    
0605    FDCE  E0 1B                   CPX    #$1B              // Was it ESC?
0606    FDD0  D0 36                   BNE    ENDLS             // No - then return
0607                    
0608    FDD2  C6 1C     ESCIT         DEC    MODADL            // Decrement memory modify address
0609    FDD4  A5 1C                   LDA    MODADL
0610    FDD6  C9 FF                   CMP    #$FF
0611    FDD8  D0 0B                   BNE    REOPEN
0612    FDDA  C6 1D                   DEC    MODADH
0613    FDDC  4C E5 FD                JMP    REOPEN
0614                    
0615    FDDF  E6 1C     WASLF         INC    MODADL            // Increment memory address
0616    FDE1  D0 02                   BNE    REOPEN
0617    FDE3  E6 1D                   INC    MODADH            // and high byte, if required
0618                    
0619    FDE5  20 73 FE  REOPEN        JSR    OUTPCR            // Output carriage return
0620    FDE8  A9 4D                   LDA    #$4D
0621    FDEA  20 75 FE                JSR    OPCHR             // Display 'M'
0622    FDED  A5 1D                   LDA    MODADH            // and address
0623    FDEF  20 0B FF                JSR    HEXPNT
0624    FDF2  A5 1C                   LDA    MODADL
0625    FDF4  20 0B FF                JSR    HEXPNT
0626    FDF7  4C 4F FC                JMP    MONEN2            // Check next command
0627                    
0628                    
0629                    //
0630                    // POLL KEYBOARD
0631                    //
0632                    // Gets a character from either the simple keypad or ASCII keyboard. Key
0633                    // value is stored in ICHAR ($01)
0634                    //
0635                    
0636    FDFA  A9 00     POLLKB        LDA    #0
0637    FDFC  48                      PHA                      // Push 0 - shift indicator
0638    FDFD  85 01     PLKB1         STA    ICHAR             // Set ICHAR to zero
0639    FDFF  C5 0F                   CMP    SIMCOM            // Check if keypad
0640    FE01  D0 06                   BNE    SIMPLE
0641                    
0642                    // ASCII keyboard routine
0643                    
0644    FE03  C5 01     WAIT1         CMP    ICHAR             // Else wait for interrupt
0645    FE05  F0 FC                   BEQ    WAIT1
0646    FE07  68        PLKEND        PLA                      // Pop indicator
0647    FE08  60        ENDLS         RTS   
0648                    
0649                    // Simple keypad routine
0650                    
0651    FE09  A9 0F     SIMPLE        LDA    #$0F
0652    FE0B  8D F2 BF                STA    KBWRIT            // Enable all keyboard lines
0653    FE0E  AD F3 BF                LDA    KBREAD            // Look at keyboard lines
0654    FE11  D0 F6                   BNE    SIMPLE            // Key down? - wait till up
0655                    
0656    FE13  A2 40                   LDX    #$40              // Debounce it
0657    FE15  88        DEBOUN        DEY   
0658    FE16  D0 FD                   BNE    DEBOUN
0659    FE18  CA                      DEX
0660    FE19  D0 FA                   BNE    DEBOUN
0661                    
0662    FE1B  A0 FF     PLK1          LDY    #$FF              // Now poll the keypad properly
0663    FE1D  68                      PLA                      // Peek at shift indicator
0664    FE1E  48                      PHA
0665    FE1F  F0 02                   BEQ    NOSHIF            // If shift set modify IY
0666    FE21  A0 13                   LDY    #$13
0667    FE23  A2 08     NOSHIF        LDX    #8                // Set IX - keyboard drive
0668    FE25  8E F2 BF  PLK2          STX    KBWRIT            // Drive keyboard lines
0669    FE28  AD F3 BF                LDA    KBREAD            // Get result
0670    FE2B  D0 0C                   BNE    ACHAR             // Not 0 - a char - so skip
0671    FE2D  C8                      INY                      // Else adjust IY
0672    FE2E  C8                      INY
0673    FE2F  C8                      INY
0674    FE30  C8                      INY
0675    FE31  C8                      INY
0676    FE32  8A                      TXA
0677    FE33  4A                      LSR    A                 // Shift IX right
0678    FE34  AA                      TAX
0679    FE35  F0 E4                   BEQ    PLK1              // If zero repeat
0680    FE37  D0 EC                   BNE    PLK2              // Else next line
0681                    
0682                    // If we get here a key has been pressed
0683                    
0684    FE39  C8        ACHAR         INY   
0685    FE3A  4A                      LSR    A                 // Which key of 5?
0686    FE3B  90 FC                   BCC    ACHAR             // C set? That's the key
0687    FE3D  B9 4B FE                LDA    CHRTBL,Y          // Get ASCII equivalent
0688    FE40  85 01                   STA    ICHAR             // And put in ICHAR
0689    FE42  D0 C3                   BNE    PLKEND            // If zero - shift
0690    FE44  68                      PLA                      // Pull shift
0691    FE45  49 FF                   EOR    #$FF              // Change shift state
0692    FE47  48                      PHA                      // Push shift
0693    FE48  4C 09 FE                JMP    SIMPLE            // ... and continue
0694                    
0695                    // Character look up table for ASCII equivalent
0696                    
0697    FE4B  33 37 42  CHRTBL        FCB    $33, $37, $42, $46, $3F, $32, $36, $41
0697    FE4E  46 3F 32  +
0697    FE51  36 41     +
0698    FE53  45 0D 31                FCB    $45, $0D, $31, $35, $39, $44, $0A, $30
0698    FE56  35 39 44  +
0698    FE59  0A 30     +
0699    FE5B  34 38 43                FCB    $34, $38, $43, $00, $2C, $52, $4C, $4E
0699    FE5E  00 2C 52  +
0699    FE61  4C 4E     +
0700    FE63  3F 32 43                FCB    $3F, $32, $43, $49, $53, $20, $31, $4F
0700    FE66  49 53 20  +
0700    FE69  31 4F     +
0701    FE6B  1B 47 7F                FCB    $1B, $47, $7F, $30, $34, $50, $4D, $00
0701    FE6E  30 34 50  +
0701    FE71  4D 00     +
0702                    
0703                    
0704                    //
0705                    // OUTPUT A CARRIAGE RETURN
0706                    //
0707                    // This subroutine causes the display to scroll up one line by outputting
0708                    // a carriage return to the screen. It also reinstates the cursor when a
0709                    // user program is run with the G command
0710                    // ACC is corrupted, IX and IY are preserved
0711                    //
0712                    
0713    FE73  A9 0D     OUTPCR        LDA    #$0D              // Output a CR
0714                    
0715                    //
0716                    // OUTPUT A CHARACTER
0717                    //
0718                    // Displays the character in the ACC on the screen
0719                    // ACC is corrupted, IX and IY are preserved
0720                    //
0721                    
0722                    #if TANEX
0723                    OPCHR         JMP    $F87C
0724                                  NOP
0725                    OPCHR1        STA    OCHAR
0726                                  LDY    VDUIND            // Get cursor position
0727                                  LDA    #$20
0728                                  STA    (ICURS),Y         // and erase cursor
0729                                  LDX    OCHAR             // Get char in IX
0730                                  CPX    #12
0731                                  BNE    TRYDEL
0732                                  JSR    $FA23
0733                    DODEL         LDA    #$FF
0734                                  STA    (ICURS),Y         // Display cursor
0735                                  STY    VDUIND            // and save index
0736                                  RTS
0737                    
0738                    TRYDEL        CPX    #$7F              // Is it delete?
0739                                  BNE    TRYCR
0740                                  JSR    $FA09
0741                                  BPL    DODEL
0742                    
0743                    TRYCR         CPX    #$0D              // Is it a CR?
0744                                  BEQ    NXLINE
0745                                  TXA                      // No, then output character
0746                                  STA    (ICURS),Y
0747                                  INY                      // Increment vdu index
0748                                  CPY    #32               // End of line?
0749                                  BNE    DODEL
0750                    NXLINE        LDA    #32
0751                                  CLC
0752                                  ADC    ICURS
0753                                  STA    ICURS
0754                                  LDA    ICURS+1
0755                                  ADC    #0
0756                                  STA    ICURS+1
0757                                  LDY    #0
0758                                  CMP    #4
0759                                  BNE    DODEL
0760                                  JSR    $FA38
0761                                  BEQ    DODEL
0762                                  NOP
0763                                  NOP
0764                                  NOP
0765                                  NOP
0766                                  NOP
0767                    
0768                    #else
0769    FE75  85 02     OPCHR         STA    OCHAR             // Save the character
0770    FE77  8A                      TXA                      // Save IX and IY
0771    FE78  48                      PHA
0772    FE79  98                      TYA
0773    FE7A  48                      PHA
0774    FE7B  A4 03                   LDY    VDUIND            // Get cursor position
0775    FE7D  A9 20                   LDA    #$20
0776    FE7F  91 0A                   STA    (ICURS),Y         // and erase cursor
0777    FE81  A6 02                   LDX    OCHAR             // Get char in IX
0778    FE83  E0 7F                   CPX    #$7F              // Is it delete?
0779    FE85  D0 10                   BNE    TRYCR
0780    FE87  88                      DEY                      // Decrement vdu index
0781    FE88  10 02                   BPL    DODEL
0782    FE8A  A0 00     ZERCUR        LDY    #0                // If negative set zero
0783    FE8C  A9 FF     DODEL         LDA    #$FF
0784    FE8E  91 0A                   STA    (ICURS),Y         // Display cursor
0785    FE90  84 03                   STY    VDUIND            // and save index
0786    FE92  68                      PLA                      // Restore registers and exit
0787    FE93  A8                      TAY
0788    FE94  68                      PLA
0789    FE95  AA                      TAX
0790    FE96  60                      RTS
0791                    
0792    FE97  E0 0D     TRYCR         CPX    #13               // Is it a CR?
0793    FE99  F0 08                   BEQ    DOCR
0794    FE9B  8A                      TXA                      // No, then output character
0795    FE9C  91 0A                   STA    (ICURS),Y
0796    FE9E  C8                      INY                      // Increment vdu index
0797    FE9F  C0 20                   CPY    #32               // End of line?
0798    FEA1  30 E9                   BMI    DODEL             // No - then tidy up and exit
0799    FEA3  A2 00     DOCR          LDX    #0                // Scroll line
0800    FEA5  BD 20 02  LOWBLK        LDA    VDUFST,X          // Do in two blocks
0801    FEA8  9D 00 02                STA    VDUSTT,X
0802    FEAB  E8                      INX
0803    FEAC  D0 F7                   BNE    LOWBLK
0804    FEAE  BD 20 03  HIBLK         LDA    VDUTOP,X
0805    FEB1  9D 00 03                STA    VDUMID,X
0806    FEB4  E8                      INX
0807    FEB5  E0 E0                   CPX    #$E0
0808    FEB7  D0 F5                   BNE    HIBLK
0809                    
0810    FEB9  A9 20                   LDA    #$20
0811    FEBB  A8                      TAY
0812    FEBC  88        MORSP         DEY                      // Fill line with spaces
0813    FEBD  91 0A                   STA    (ICURS),Y
0814    FEBF  D0 FB                   BNE    MORSP
0815    FEC1  F0 C7                   BEQ    ZERCUR            // When done, tidy up
0816                    #endif
0817                    
0818                    
0819                    //
0820                    // KEYBOARD INTERRUPT
0821                    //
0822                    // Note this is entered via jump instruction stored in RAM location INTFS1
0823                    // so that user can access interrupts quickly.
0824                    // A reset will always initiate INTFS1
0825                    //
0826                    
0827    FEC3  48        KBINT         PHA                      // Save accumulator
0828    FEC4  D8                      CLD                      // Set binary mode
0829    FEC5  8A                      TXA                      // Save IX
0830    FEC6  48                      PHA
0831    FEC7  BA                      TSX                      // Get SP in IX
0832    FEC8  E8                      INX                      // Point IX to old PSW
0833    FEC9  E8                      INX
0834    FECA  E8                      INX
0835    FECB  BD 00 01                LDA    STKBSE,X          // and get the PSW
0836    FECE  29 10                   AND    #$10              // Was it a break? 
0837    FED0  D0 1E                   BNE    BRKP              // Yes - then process it
0838    FED2  68                      PLA                      // Else restore IX
0839    FED3  AA                      TAX
0840                    #if TANEX
0841                                  JSR    $FAA3
0842                    #else
0843    FED4  AD F3 BF                LDA    KBREAD            // Read keyboard
0844                    #endif
0845    FED7  30 04                   BMI    WASKB             // If -ve, then was keyboard
0846    FED9  68        USER          PLA                      // Else restore A
0847    FEDA  4C 10 00                JMP    INTSL1            // and check the slow interrupt
0848                                                           // Note that INTSL1 normally holds an RTI,
0849                                                           // unless the user has modified it
0850                    
0851    FEDD  29 7F     WASKB         AND    #$7F              // Mask top bit
0852    FEDF  85 01                   STA    ICHAR             // and store in ICHAR
0853                    #if TANEX
0854                                  JSR    $F911
0855                    #else
0856    FEE1  8D F0 BF                STA    KBINCL            // Clear keyboard interrupt flip-flop
0857                    #endif
0858    FEE4  C9 1B                   CMP    #$1B              // Was key ESC?
0859    FEE6  D0 F1                   BNE    USER              // No - then normal return
0860    FEE8  A5 0C                   LDA    RUNIND            // Else - check if user program running?
0861    FEEA  D0 ED                   BNE    USER              // No - then normal return
0862    FEEC  85 0E                   STA    PROCED            // Else clear proceed count
0863    FEEE  F0 12                   BEQ    ACTBP             // and unconditionally branch to break
0864                    
0865                    
0866                    //
0867                    // BREAK PROCESSING
0868                    //
0869                    // Note the user should not set a break at own break or in this interrupt routine
0870                    // else crashes. Adjust PC to return to instr must subtract 3
0871                    //
0872                    
0873    FEF0  E8        BRKP          INX                      // address PC L
0874    FEF1  38                      SEC                      // set C
0875    FEF2  BD 00 01                LDA    STKBSE,X          // get PCL
0876    FEF5  E9 02                   SBC    #2                // subtract 3
0877    FEF7  9D 00 01                STA    STKBSE,X          // put it back
0878    FEFA  B0 04                   BCS    NOROLL            // C set? NOHI byte
0879    FEFC  E8                      INX                      // else address PCH
0880    FEFD  DE 00 01                DEC    STKBSE,X          // dec PCH
0881    FF00  68        NOROLL        PLA                      // pull IX
0882    FF01  AA                      TAX                      // restore it
0883    FF02  68        ACTBP         PLA                      // pull accumulator
0884    FF03  85 1B                   STA    ABCK              // back it up
0885    FF05  20 C1 FF                JSR    BPTREM            // restore user code
0886    FF08  4C 75 FF  NOROL         JMP    NMNT1             // service break
0887                    
0888                    
0889                    //
0890                    // DISPLAY HEX VALUES
0891                    //
0892                    // Takes a hex value stored in accumulator and displays as two hex characters
0893                    // Registers ACC and IX are corrupted
0894                    //
0895                    
0896    FF0B  48        HEXPNT        PHA                      // Save value of char
0897    FF0C  A2 01                   LDX    #1
0898    FF0E  4A                      LSR    A                 // Get top part by multiple shifts
0899    FF0F  4A                      LSR    A
0900    FF10  4A                      LSR    A
0901    FF11  4A                      LSR    A
0902    FF12  18        PNT2          CLC   
0903    FF13  69 30                   ADC    #$30              // Add hex 30
0904    FF15  C9 3A                   CMP    #$3A              // More than 9?
0905    FF17  30 03                   BMI    PNT1              // No - then display it
0906    FF19  18                      CLC
0907    FF1A  69 07                   ADC    #7                // Adjust again
0908    FF1C  20 75 FE  PNT1          JSR    OPCHR             // and display it
0909    FF1F  CA                      DEX
0910    FF20  10 01                   BPL    MOR1              // -ve? - end else low bit
0911    FF22  60                      RTS
0912                    
0913    FF23  68        MOR1          PLA                      // Recover character
0914    FF24  29 0F                   AND    #$0F              // Clear unwanted bits
0915    FF26  10 EA                   BPL    PNT2              // and branch unconditionally
0916                    
0917                    
0918                    //
0919                    // PACK HEX CHARACTERS
0920                    //
0921                    // This subroutine reads hex characters from the bottom line of the display
0922                    // and packs them up into two eight bit binary values.
0923                    // On exit, caused by any non-hex character, HXPKL and HXPKH contain a two
0924                    // byte number.
0925                    // Registers are not saved. On exit IY points to the last character. The zero flag
0926                    // is clear if the terminating character was the cursor, else set. The overflow
0927                    // flag is set if this subroutine encountered some hex data. 
0928                    //
0929                    
0930    FF28  A9 00     HEXPCK        LDA    #0                // Clear accumulator
0931    FF2A  48                      PHA                      // Push as PSW
0932    FF2B  85 13                   STA    HXPKL             // Clear parameters
0933    FF2D  85 14                   STA    HXPKH
0934    FF2F  C8        NXHX          INY   
0935    FF30  B1 0A                   LDA    (ICURS),Y         // Get character from display
0936    FF32  AA                      TAX                      // Save in IX
0937    FF33  38                      SEC
0938    FF34  E9 30                   SBC    #$30              // Subtract hex 30 to give 0 to 9
0939    FF36  30 10                   BMI    ENDTS
0940    FF38  C9 0A     HX1           CMP    #$0A              // Is it 0 to 9?
0941    FF3A  30 10                   BMI    HX2               // Yes - then pack it
0942    FF3C  38                      SEC                      // Else adjust by hex 11
0943    FF3D  E9 11                   SBC    #$11
0944    FF3F  30 07                   BMI    ENDTS             // Goto carry setup
0945    FF41  18        HX3           CLC                      // Else add 9
0946    FF42  69 0A                   ADC    #$0A
0947    FF44  C9 10                   CMP    #$10              // If more than 15, then exit
0948    FF46  30 04                   BMI    HX2
0949    FF48  28        ENDTS         PLP                      // Deal with V flag
0950    FF49  E0 FF                   CPX    #$FF              // Check if cursor
0951    FF4B  60                      RTS
0952                    
0953                    // Note character is in IX on exit, return does not affect zero flag
0954                    
0955    FF4C  A2 04     HX2           LDX    #4
0956    FF4E  06 14     HX5           ASL    HXPKH             // Shift result left 4 bits
0957    FF50  06 13                   ASL    HXPKL
0958    FF52  90 02                   BCC    HX4
0959    FF54  E6 14                   INC    HXPKH
0960    FF56  CA        HX4           DEX                      // Until IX zero (4 times)
0961    FF57  D0 F5                   BNE    HX5
0962    FF59  18                      CLC
0963    FF5A  65 13                   ADC    HXPKL             // Add in character
0964    FF5C  85 13                   STA    HXPKL
0965    FF5E  68                      PLA                      // Get pseudo PSW
0966    FF5F  A9 40                   LDA    #$40              // Set V bit
0967    FF61  48                      PHA                      // and push it
0968    FF62  D0 CB                   BNE    NXHX              // Next ...
0969                    
0970                    
0971                    //
0972                    // NON-MASKABLE INTERRUPT
0973                    //
0974                    // This routine handles single instruction mode
0975                    //
0976                    
0977    FF64  85 1B     NMNT          STA    ABCK              // Save accumulator
0978    FF66  D8                      CLD                      // Set binary mode
0979    FF67  A5 0D                   LDA    SINGLE            // Test single instruction mode
0980    FF69  D0 0A                   BNE    NMNT1
0981    FF6B  8A                      TXA                      // If not save IX
0982    FF6C  48                      PHA
0983    FF6D  20 D0 FF                JSR    BPSET             // Set breakpoints
0984    FF70  68                      PLA                      // Restore IX
0985    FF71  AA                      TAX
0986    FF72  A5 1B                   LDA    ABCK              // Restore accumulator
0987    FF74  40                      RTI
0988                    
0989    FF75  A5 0E     NMNT1         LDA    PROCED            // Get proceed count
0990    FF77  F0 05                   BEQ    ZERBCK            // If zero, then break
0991    FF79  C6 0E                   DEC    PROCED            // else decrement count
0992    FF7B  4C B9 FC                JMP    SRET              // RTS via single test
0993                    
0994    FF7E  E6 0C     ZERBCK        INC    RUNIND            // Set not running
0995    FF80  68                      PLA                      // Pop breakpoint PSW to Acc
0996    FF81  85 17                   STA    PSWBCK            // and back it up
0997    FF83  68                      PLA
0998    FF84  85 15                   STA    PCLBCK            // Ditto PCL
0999    FF86  68                      PLA
1000    FF87  85 16                   STA    PCHBCK            // Ditto PCH
1001    FF89  86 19                   STX    XBCK              // Save IX
1002    FF8B  84 1A                   STY    YBCK              // and IY
1003    FF8D  BA                      TSX
1004    FF8E  86 18                   STX    SPBCK             // and operators SP
1005    FF90  20 73 FE  PSEUD         JSR    OUTPCR
1006    FF93  A5 16                   LDA    PCHBCK
1007    FF95  20 0B FF                JSR    HEXPNT            // Display PC
1008    FF98  A5 15                   LDA    PCLBCK
1009    FF9A  20 0B FF                JSR    HEXPNT
1010    FF9D  A0 00                   LDY    #0
1011    FF9F  A9 20     PSNX          LDA    #$20              // Display two spaces
1012    FFA1  48                      PHA
1013    FFA2  20 75 FE                JSR    OPCHR
1014    FFA5  68                      PLA
1015    FFA6  20 75 FE                JSR    OPCHR
1016    FFA9  B9 17 00                LDA    PSWBCK,Y          // Then display all registers
1017    FFAC  20 0B FF                JSR    HEXPNT
1018    FFAF  C8                      INY
1019    FFB0  C0 05                   CPY    #5
1020    FFB2  30 EB                   BMI    PSNX
1021    FFB4  4C 4B FC                JMP    RC1
1022                    
1023                    
1024                    //
1025                    // CLEAR BREAKPOINTS
1026                    //
1027                    // Sets all breakpoint addresses to zero
1028                    //
1029                    
1030    FFB7  A2 1F     BPTCLR        LDX    #$1F              // Set count for 8 breakpoints
1031    FFB9  A9 00                   LDA    #0
1032    FFBB  95 20     BPTCL1        STA    BPTLO,X           // Set to zero
1033    FFBD  CA                      DEX
1034    FFBE  10 FB                   BPL    BPTCL1            // For all locations
1035    FFC0  60                      RTS
1036                    
1037                    
1038                    //
1039                    // REMOVE BREAKPOINTS
1040                    //
1041                    // Writes back the user's original code
1042                    //
1043                    
1044    FFC1  8A        BPTREM        TXA   
1045    FFC2  48                      PHA
1046    FFC3  A2 0E                   LDX    #$0E              // Set count for 8 breakpoints
1047                    BPTRM1                                 //
1048                    #if TANEX
1049                                  LDA    BPTLO,X
1050                                  ORA    BPTHI,X
1051                                  BEQ    BPTRM2
1052                    #endif
1053    FFC5  B5 30                   LDA    BPTCOD,X          // Load saved old instruction
1054    FFC7  81 20                   STA    (BPTLO,X)         // Write to program memory
1055    FFC9  CA        BPTRM2        DEX   
1056    FFCA  CA                      DEX
1057    FFCB  10 F8                   BPL    BPTRM1            // For all locations
1058    FFCD  68                      PLA
1059    FFCE  AA                      TAX
1060    FFCF  60                      RTS
1061                    
1062                    
1063                    //
1064                    // SET BREAKPOINTS
1065                    //
1066                    // Examines entered breakpoint addresses, stores the present instruction
1067                    // and writes BRK opcode to program memory
1068                    //
1069                    
1070    FFD0  A2 0E     BPSET         LDX    #$0E              // Set count for 8 breakpoints
1071                    BPS1                                   //
1072                    #if TANEX
1073                                  LDA    BPTHI,X
1074                                  ORA    BPTLO,X
1075                                  BEQ    BPS2
1076                    #endif
1077    FFD2  A1 20                   LDA    (BPTLO,X)         // Get user's instruction
1078    FFD4  95 30                   STA    BPTCOD,X          // Store it
1079    FFD6  A9 00                   LDA    #0
1080    FFD8  81 20                   STA    (BPTLO,X)         // Set BRK instruction...
1081    FFDA  CA        BPS2          DEX   
1082    FFDB  CA                      DEX
1083    FFDC  10 F4                   BPL    BPS1              // Repeat until done
1084    FFDE  60                      RTS
1085                    
1086                    
1087                    #if TANEX
1088                    //	Setup table in low ROM
1089                    
1090                    #else
1091                    
1092                    //
1093                    // SETUP TABLE
1094                    //
1095                    // Copy in ROM of the initial settings for zero page variables
1096                    //
1097                    
1098    FFDF  4C C3 FE  SETUP         JMP    KBINT
1099    FFE2  4C 64 FF                JMP    NMNT
1100    FFE5  E0 03                   FDB    LINBOT            // ICURS setting
1101    FFE7  01                      FCB    1                 // RUNIND
1102    FFE8  00                      FCB    0                 // SINGLE
1103    FFE9  00                      FCB    0                 // PROCED
1104    FFEA  00                      FCB    0                 // SIMCOM
1105    FFEB  40                      FCB    $40               // Slow Interrupt (RTI instruction)
1106                    
1107                    #endif
1108                    
1109                    
1110                    // Header message
1111                    
1112    FFEC  0D        HDR           FCB    13                // CR
1113    FFED  54 41 4E                FCC    'TANBUG'
1113    FFF0  42 55 47  +
1114    FFF3  0D 00                   FCB    13, 0             // CR, end of line terminator
1115                    
1116                    #if TANEX
1117                                  NOP
1118                                  NOP
1119                                  NOP
1120                    #else
1121    FFF5  00 00                   FCB    0, 0              // Padding
1122                    #endif
1123                    
1124                    
1125                    //
1126                    // RESET / INTERRUPT VECTORS
1127                    //
1128                    // These vectors must appear at the top of the ROM space
1129                    //
1130                    
1131    FFF7  4C 89 FC                JMP    RETERR            // $FFF7, also mapped to $F7F7
1132    FFFA  07 00                   FDB    NMIJP             // Non Maskable Interrupt vector
1133    FFFC  00 FC                   FDB    START             // Reset vector
1134    FFFE  04 00                   FDB    INTFS1            // Interrupt vector
1135                    
1136                                  END

Assembly generated 0 errors and 0 warnings

Symbols table (147):
[0047]D 001B ABCK                [0684]L FE39 ACHAR               [0883]L FF02 ACTBP               
[1071]L FFD2 BPS1                [1081]L FFDA BPS2                [1070]L FFD0 BPSET               
[1032]L FFBB BPTCL1              [1030]L FFB7 BPTCLR              [0060]D 0030 BPTCOD              
[0059]D 0021 BPTHI               [0058]D 0020 BPTLO               [1044]L FFC1 BPTREM              
[1047]L FFC5 BPTRM1              [1055]L FFC9 BPTRM2              [0873]L FEF0 BRKP                
[0697]L FE4B CHRTBL              [0054]D 001F COPH                [0053]D 001E COPL                
[0657]L FE15 DEBOUN              [0520]L FD68 DELX1               [0799]L FEA3 DOCR                
[0783]L FE8C DODEL               [0647]L FE08 ENDLS               [0949]L FF48 ENDTS               
[0390]L FCD8 EQPT                [0539]L FD80 ERJUM2              [0299]L FC86 ERRQ                
[0608]L FDD2 ESCIT               [0408]L FCF3 GETPT2              [0333]L FCA3 GOEND               
[1112]L FFEC HDR                 [0930]L FF28 HEXPCK              [0896]L FF0B HEXPNT              
[0804]L FEAE HIBLK               [0940]L FF38 HX1                 [0955]L FF4C HX2                 
[0945]L FF41 HX3                 [0960]L FF56 HX4                 [0956]L FF4E HX5                 
[0037]D 0014 HXPKH               [0036]D 0013 HXPKL               [0025]D 0001 ICHAR               
[0582]L FDAD ICMCOP              [0030]D 000A ICURS               [0083]D F7F7 INPERR              
[0028]D 0004 INTFS1              [0035]D 0010 INTSL1              [0188]L FC42 ISTERM              
[0485]L FD48 JPRTRN              [0077]D BFF0 KBINCL              [0827]L FEC3 KBINT               
[0080]D BFF3 KBREAD              [0079]D BFF2 KBWRIT              [0169]L FC29 KPCPLX              
[0072]D 03E0 LINBOT              [0474]L FD34 LINK1               [0405]L FCEF LINKPH              
[0406]L FCF0 LINKR               [0497]L FD49 LISTIT              [0800]L FEA5 LOWBLK              
[0594]L FDBC MEM100              [0052]D 001D MODADH              [0051]D 001C MODADL              
[0191]L FC48 MONCH1              [0195]L FC4F MONEN2              [0182]L FC37 MONTOR              
[0913]L FF23 MOR1                [0403]L FCEB MOREY               [0537]L FD7C MOREY1              
[0812]L FEBC MORSP               [0309]L FC8F MULTI               [0029]D 0007 NMIJP               
[0977]L FF64 NMNT                [0989]L FF75 NMNT1               [0602]L FDCA NOENT               
[0585]L FDB3 NOHIH1              [0886]L FF08 NOROL               [0881]L FF00 NOROLL              
[0667]L FE23 NOSHIF              [0444]L FD14 NOTOPO              [0024]D 0000 NULL                
[0574]L FD9D NXCOP               [0934]L FF2F NXHX                [0498]L FD4C NXLI                
[0502]L FD55 NXLIST              [0026]D 0002 OCHAR               [0769]L FE75 OPCHR               
[0713]L FE73 OUTPCR              [0042]D 0016 PCHBCK              [0041]D 0015 PCLBCK              
[0662]L FE1B PLK1                [0668]L FE25 PLK2                [0638]L FDFD PLKB1               
[0646]L FE07 PLKEND              [0368]L FCC9 PNOARG              [0908]L FF1C PNT1                
[0902]L FF12 PNT2                [0458]L FD28 PNTITO              [0636]L FDFA POLLKB              
[0367]L FCC7 PROC1               [0033]D 000E PROCED              [1005]L FF90 PSEUD               
[1011]L FF9F PSNX                [0043]D 0017 PSWBCK              [0192]L FC4B RC1                 
[0619]L FDE5 REOPEN              [0302]L FC89 RETERR              [0456]L FD25 RNGNG               
[0031]D 000C RUNIND              [1098]L FFDF SETUP               [0149]L FC0E SETUP1              
[0076]D BFF0 SGRAPH              [0034]D 000F SIMCOM              [0651]L FE09 SIMPLE              
[0032]D 000D SINGLE              [0078]D BFF1 SNMI                [0044]D 0018 SPBCK               
[0346]L FCB9 SRET                [0132]L FC00 START               [0081]D BFF3 STEXT               
[0064]D 0100 STKBSE              [0020]D 0000 TANEX               [0171]L FC2C TBMS                
[0541]L FD83 TERMOK              [0287]L FC7E TRYB                [0473]L FD32 TRYBPT              
[0792]L FE97 TRYCR               [0388]L FCD4 TRYM                [0232]L FC62 TRYN                
[0249]L FC69 TRYP                [0363]L FCBF TRYPL               [0263]L FC71 TRYR                
[0217]L FC5B TRYS                [0158]L FC17 TSFIV               [0846]L FED9 USER                
[0069]D 0220 VDUFST              [0027]D 0003 VDUIND              [0070]D 0300 VDUMID              
[0068]D 0200 VDUSTT              [0071]D 0320 VDUTOP              [0644]L FE03 WAIT1               
[0851]L FEDD WASKB               [0615]L FDDF WASLF               [0045]D 0019 XBCK                
[0046]D 001A YBCK                [0994]L FF7E ZERBCK              [0782]L FE8A ZERCUR              

